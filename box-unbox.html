<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="archaea.css">
<script type="text/javascript" src="jquery-2.0.2.min.js"></script>
<script type="text/javascript" src="archaea.js"></script>
<button id="back"></button>
<button id="forward"></button>
<button id="action" class="start"></button>
<button id="reset"></button>
<span id="status"></span>
<revisions count="31">
<code num="0" date="2010-06-23 21:03:09 -0700" desc="Populate tree.">
type box[T] = tup(@T);

fn unbox[T](box[T] b) -&gt; T { ret b._0; }

fn main() {
  let int foo = 17;
  let box[int] bfoo = tup(foo);
  log "see what's in our box";
  check (unbox[int](bfoo) == foo);
}
</code>
<code num="1" date="2010-07-01 18:37:30 -0700" desc="Correct existing reliance on auto-box / unbox behavior in tests.">
type box[T] = tup(@T);

fn unbox[T](box[T] b) -&gt; T { ret *b._0; }

fn main() {
  let int foo = 17;
  let box[int] bfoo = tup(@foo);
  log "see what's in our box";
  check (unbox[int](bfoo) == foo);
}
</code>
<code num="2" date="2011-01-27 13:49:27 -0800" desc="Fix bug in box-unbox.rs test.">
type box[T] = tup(@T);

fn unbox[T](&amp;box[T] b) -&gt; T { ret *b._0; }

fn main() {
  let int foo = 17;
  let box[int] bfoo = tup(@foo);
  log "see what's in our box";
  check (unbox[int](bfoo) == foo);
}
</code>
<code num="3" date="2011-05-02 11:23:07 -0700" desc="Use different syntax for checks that matter to typestate">
type box[T] = tup(@T);

fn unbox[T](&amp;box[T] b) -&gt; T { ret *b._0; }

fn main() {
  let int foo = 17;
  let box[int] bfoo = tup(@foo);
  log "see what's in our box";
  assert (unbox[int](bfoo) == foo);
}
</code>
<code num="4" date="2011-05-02 16:24:09 -0700" desc="Revert "Use different syntax for checks that matter to typestate"">
type box[T] = tup(@T);

fn unbox[T](&amp;box[T] b) -&gt; T { ret *b._0; }

fn main() {
  let int foo = 17;
  let box[int] bfoo = tup(@foo);
  log "see what's in our box";
  check (unbox[int](bfoo) == foo);
}
</code>
<code num="5" date="2011-05-02 17:47:24 -0700" desc="Un-revert "Use different syntax for checks that matter to typestate", fixing the problem.">
type box[T] = tup(@T);

fn unbox[T](&amp;box[T] b) -&gt; T { ret *b._0; }

fn main() {
  let int foo = 17;
  let box[int] bfoo = tup(@foo);
  log "see what's in our box";
  assert (unbox[int](bfoo) == foo);
}
</code>
<code num="6" date="2011-06-15 11:19:50 -0700" desc="Reformat source tree (minus a couple tests that are still grumpy).">
type box[T] = tup(@T);

fn unbox[T](&amp;box[T] b) -&gt; T { ret *b._0; }

fn main() {
    let int foo = 17;
    let box[int] bfoo = tup(@foo);
    log "see what's in our box";
    assert (unbox[int](bfoo) == foo);
}
</code>
<code num="7" date="2011-07-26 14:49:40 +0200" desc="Remove uses of tuples from the test suite">
type box[T] = rec(@T c);

fn unbox[T](&amp;box[T] b) -&gt; T { ret *b.c; }

fn main() {
    let int foo = 17;
    let box[int] bfoo = rec(c=@foo);
    log "see what's in our box";
    assert (unbox[int](bfoo) == foo);
}
</code>
<code num="8" date="2011-07-27 14:19:39 +0200" desc="Reformat for new syntax">
type box[T] = {c: @T};

fn unbox[T](b: &amp;box[T]) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box[int] = {c: @foo};
    log "see what's in our box";
    assert (unbox[int](bfoo) == foo);
}
</code>
<code num="9" date="2011-08-10 09:27:22 -0700" desc="Port the tests to the typaram foo&lt;T&gt; syntax.">
type box[T] = {c: @T};

fn unbox[T](b: &amp;box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox[int](bfoo) == foo);
}
</code>
<code num="10" date="2011-08-12 06:37:25 -0700" desc="Port the tests to the decl foo&lt;T&gt; syntax.">
type box&lt;T&gt; = {c: @T};

fn unbox&lt;T&gt;(b: &amp;box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox[int](bfoo) == foo);
}
</code>
<code num="11" date="2011-08-13 00:10:18 -0700" desc="Port the tests to the expr foo::&lt;T&gt; syntax.">
type box&lt;T&gt; = {c: @T};

fn unbox&lt;T&gt;(b: &amp;box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="12" date="2011-08-23 15:58:53 -0700" desc="Add kind-checking for assign-op, copy, ret, be, fail exprs. Fix caught kinding-violations in rustc and libstd.">
type box&lt;T&gt; = {c: @T};

fn unbox&lt;@T&gt;(b: &amp;box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="13" date="2011-09-12 11:27:30 +0200" desc="Reformat for new mode syntax, step 1">
type box&lt;T&gt; = {c: @T};

fn unbox&lt;@T&gt;(b: box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="14" date="2011-10-25 15:56:55 +0200" desc="Update our code to new type parameter kind syntax">
type box&lt;T&gt; = {c: @T};

fn unbox&lt;T&gt;(b: box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="15" date="2011-11-18 12:39:20 +0100" desc="Update stdlib, compiler, and tests to new kind system">
type box&lt;copy T&gt; = {c: @T};

fn unbox&lt;copy T&gt;(b: box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    log "see what's in our box";
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="16" date="2011-12-22 14:42:52 -0800" desc="Register snapshots and switch logging over to use of log_full or #error / #debug.">
type box&lt;copy T&gt; = {c: @T};

fn unbox&lt;copy T&gt;(b: box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    #debug("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="17" date="2012-01-05 15:35:37 +0100" desc="Switch to new param kind bound syntax">
type box&lt;T: copy&gt; = {c: @T};

fn unbox&lt;T: copy&gt;(b: box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    #debug("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="18" date="2012-07-30 16:01:07 -0700" desc="Change syntax extension syntax: `#m[...]` -&gt; `m!{...}`.">
type box&lt;T: copy&gt; = {c: @T};

fn unbox&lt;T: copy&gt;(b: box&lt;T&gt;) -&gt; T { ret *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    debug!{"see what's in our box"};
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="19" date="2012-08-01 17:30:05 -0700" desc="Convert ret to return">
type box&lt;T: copy&gt; = {c: @T};

fn unbox&lt;T: copy&gt;(b: box&lt;T&gt;) -&gt; T { return *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    debug!{"see what's in our box"};
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="20" date="2012-08-22 17:24:52 -0700" desc="`m1!{...}` -&gt; `m1!(...)`">
type box&lt;T: copy&gt; = {c: @T};

fn unbox&lt;T: copy&gt;(b: box&lt;T&gt;) -&gt; T { return *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="21" date="2012-09-07 14:52:28 -0700" desc="Convert all kind bounds to camel case. Remove send, owned keywords.">
type box&lt;T: Copy&gt; = {c: @T};

fn unbox&lt;T: Copy&gt;(b: box&lt;T&gt;) -&gt; T { return *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="22" date="2012-12-10 17:32:48 -0800" desc="Reliciense makefiles and testsuite. Yup.">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



type box&lt;T: Copy&gt; = {c: @T};

fn unbox&lt;T: Copy&gt;(b: box&lt;T&gt;) -&gt; T { return *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: box&lt;int&gt; = {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="23" date="2013-01-25 22:46:32 -0800" desc="testsuite: Eliminate uses of structural records from most run-pass tests">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T: Copy&gt; {c: @T}

fn unbox&lt;T: Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="24" date="2013-01-28 10:46:43 -0800" desc="librustc: Disallow trait bounds in types, enumerations, and structure definitions. r=tjc">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T: Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="25" date="2013-02-01 19:43:17 -0800" desc="check-fast fallout from removing export, r=burningtree">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T: Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

pub fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="26" date="2013-02-20 17:07:17 -0800" desc="librustc: Separate most trait bounds with '+'. rs=plussing">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T:Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

pub fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert (unbox::&lt;int&gt;(bfoo) == foo);
}
</code>
<code num="27" date="2013-03-06 13:58:02 -0800" desc="librustc: Convert all uses of `assert` over to `fail_unless!`">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T:Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

pub fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    fail_unless!((unbox::&lt;int&gt;(bfoo) == foo));
}
</code>
<code num="28" date="2013-03-28 18:39:09 -0700" desc="librustc: Remove `fail_unless!`">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T:Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

pub fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert!((unbox::&lt;int&gt;(bfoo) == foo));
}
</code>
<code num="29" date="2013-05-18 22:02:45 -0400" desc="Use assert_eq! rather than assert! where possible">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T:Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return *b.c; }

pub fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert_eq!(unbox::&lt;int&gt;(bfoo), foo);
}
</code>
<code num="30" date="2013-06-15 20:26:59 -0400" desc="Add copies to type params with Copy bound">
// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.



struct Box&lt;T&gt; {c: @T}

fn unbox&lt;T:Copy&gt;(b: Box&lt;T&gt;) -&gt; T { return copy *b.c; }

pub fn main() {
    let foo: int = 17;
    let bfoo: Box&lt;int&gt; = Box {c: @foo};
    debug!("see what's in our box");
    assert_eq!(unbox::&lt;int&gt;(bfoo), foo);
}
</code>
</revisions>
